/*
struct QueueItem {
  char data[DATASIZE];      //Space for the string to be stored
  struct QueueItem* next; //Next item in the queue
};

struct Queue {
  struct QueueItem *front;  //Item at the front of the queue
  struct QueueItem *rear;   //Item at the end of the queue
};

//Generates new Queue Item
struct QueueItem* newItem(char newData[DATASIZE]){
  struct QueueItem* i = (struct QueueItem*)malloc(sizeof(struct QueueItem));
  strcat(i->data, newData);
  i->next = NULL;
  return i;
}

//Generates empty queue
struct Queue* createQueue(){
  struct Queue* q = (struct Queue*)malloc(sizeof(struct Queue));
  q->front = NULL;
  q->rear = NULL;
  return q;
};

//Add item to the back of the queue
void push(struct Queue* q, char data[DATASIZE]){
  //Build new item to be added
  struct QueueItem* i = newItem(data);

  //Check if queue is empty
  if(q->rear == NULL){
    //If empty, add i and set rear and front to be i since it is the only thing in the queue
    q->rear = i;
    q->front = i;
  } else {
    //If not empty, add i to the back of the queue
    q->rear->next = i;
    q->rear = i;
  }
}

//Take the item out of the front of the queue and retun it
char * pop(struct Queue* q){
  //Check if queue is empty
  if(q->rear == NULL){
    printf("checkpoint \n");
    return emptyString;
  }

  //Take item from front of queue and save it in a tep var
  struct QueueItem* poppedItem = q->front;

  //Redefine the front of the queue as the second to front, essentially removing the actual front of the queue
  q->front = q->front->next;

  //check to see of the queue is now empty, if it is, make sure the rear reflects that
  if(q->front == NULL){
    q->rear = NULL;
  }


  //Return the popped items key (contents)
  return poppedItem->data;
}
*/
